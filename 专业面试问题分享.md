### 排序有几种方式，分别介绍其实现原理？时间复杂度与空间复杂度？
具体答案看我的博客http://www.cnblogs.com/PIRATE-JFZHOU
### 平衡二叉树
平衡二叉树是这样一种二叉树，它的左右子树的深度相差不超过1,它的左右子树也符合上述的条件的二叉树
### STL中list和map对应的数据结构
STL中的list对应的是一个双向的链表，map的底层数据结构是红黑树
### 单向链表和双向链表的数据结构的实现
单向链表的实现
```
template<typename T>
struct list{
T val;
list * ptr;
}
```
双向链表的实现
```
template<typename T>
struct dou_list{
T val;
dou_list* pre;
dou_list* former;
}
```
### hashmap中value的底层存储结构
hashmap的底层存储结构都是红黑树
### 哈希的主要原理
哈希表是根据关键码值而直接进行访问的数据结构，也就是通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数
### 怎样判断一个链表有环
设置两个指针都指向头节点，然后两个指针同时出发，一个慢指针每次只走一步，快指针走两步，如果快指针为null，那么链表无环，如果在某一时刻，快指针等于慢指针，那么链表有环，程序如下：
```
bool judge(list* head){
	list* fast=head;
	list* slow=head;
	while(fast!=null){
        	list* lnode=fast;
        	if(lnode->next!=null){
                	lnode=lnode->next;
        	}
        	else
        	{
                	return false;
        	}
		slow=lnode;
		if(lnode->next!=null){
			lnode=lnode-next
		}
		else
		{
			return false;
		}
		fast=lnode;
		if(fast->val==slow->val){
			return true;
		}
	}
}
```
### 两个有序的单链表如何合并成一个有序的单链表
程序代码如下所示：
```
list * merge(list *list1,list* list2){
	if(list1==null){
		return list2;
	}
	if(list2==null){
		return list1;
	}
	list* lnode1=list1;
	list* lnode2=list2;
	list* res=null;
	list* nextlnode=res;
	while(lnode1!=null && lnode2!=null){
		list * lnode=new list;
		if(lnode1->val<lnode2->val){
			lnode->val=lnode1->val;
			lnode1=lnode1->next;
		}
		else{
			lnode->val=lnode2->val;
			lnode2=lnode2->next;
		}
		nextlnode->next=lnode;
		nextlnode=nextlnode->next;
	}
	while(lnode1!=null){
		list*lnode=new list;
		lnode->val=lnode1->val;
		nextlnode->next=lnode;
		nextlnode=nextlnode->next;
		lnode1=lnode1->next;
	}
	while(lnode2!=null){
		list*lnode=new list;
		lnode->val=lnode2->val;
		nextlnode->next=lnode;
		nextlnode=nextlnode->next;
		lnode2=lnode2->next;
	}
	return res;
}
```
### 一个特别大的数据，怎么计算给定范围的数组之和

### 五子棋怎么判赢
检查当前落子的一行，左上右下和左下右上斜线是否有5个同样颜色的棋子
### 布龙过滤器，主要还是检查一个数据是否在海量数据中的方法
哈希
### 俄罗斯方块游戏数据结构怎么设计？怎么表示形状？怎么表示消除？
一个二维数组，0和1,0表示有方块，1表示无方块
### 搜索的时候输入一个字开始提示怎么实现的

### 在使用淘点点的时候，怎么查找最近100家商店，数据量大，说出算法思想，要求效率高？

### 100个数怎么选出三个最大的数
我的想法是用冒泡排序就可以，循环三次，或者用直接选择排序也可以，时间复杂度为n,空间复杂度为1
### 找出一个字符串中第一个出现的次数为1的字符的下标
建立一个大小为256的字符数组，第一遍遍历数组，统计每个字符在字符串中出现的次数，并且存储在哈希表中，第二遍遍历时，检查哈希表的值是否为1即可
### int 数组中保存了一些整数，如{1,2,3}，实现一个数组加1的函数，不考虑{0,1,2,3}这种情况
--我也没明白这提什么意思
### 双向链表排序用什么算法比较好？
因为双向链表不能随机访问，所以那些要求随机访问的都不理想，用冒泡可能好一些
### 红黑树，平衡二叉树和B树的区别
首先，红黑树和平衡二叉树都是二叉树，区别在于平衡二叉树保持着绝对的平衡，要使一棵树恢复到平衡二叉树可能需要很多步骤，相比来说，红黑树是一种比较弱的平衡，也就是平衡条件不是非常苛刻，相比带来的好处是最多可以通过三次旋转变换使得一个二叉树恢复平衡
其次，B树不是二叉树，它通常用在磁盘存储文件中
### 栈用数组怎么实现

### map的实现原理
map的底层数据结构是红黑树，红黑树从本质上讲是一种二叉搜索树，平均查找时间为log2(n)
### STL的容器有那些？分别介绍其实现原理
容器分为两种：
1、序列式容器，包括vector、list、deque、stack、queue、head、priority_queue、slist
2、关联式容器，包括set、map、multiset、multimap、hashtable
vector实质上是一种动态数组
list是环形双向链表
deque相比vector的单向增长，deque可以在前端插入数据，而且没有所谓的容量的概念
stack是栈，底层实现只是将deque单端闭口而已
queue是队列，有两种实现方式，一种是以list实现，一种是以deque实现
priority_queue是以heap也就是堆的实现方式
slist是单向链表
关联式容器都是以红黑树为底层实现
### 1,2,3,4,5,7,6这个序列的如果排序你会怎么做，为什么？如果完全无序会怎么做？
数组基本有序，所以用冒泡、插入实际上都可以，完全无序的话，归并排序
### 两个数进行交换，不额外使用变量，怎么做
x=x+y
y=x-y
x=x-y
### 说出自己熟悉的排序算法以及每种算法的优缺点
插入排序：插入排序是稳定的排序，在最好情况下时间复杂度为n，最差情况下为n的平方，平均复杂度为n的平方
shell排序：不稳定，最好情况下时间复杂度为n，最差为n的平方，平均复杂度为n的1.3次方
选择排序：不稳定，最好情况下时间复杂度为n的平方，最差为n的平方，平均复杂度为n的平方
堆排序：不稳定，最好情况下时间复杂度为nlog(n)，最差为nlog(n)，平均复杂度为nlog(n)
冒泡排序：稳定，最好情况下时间复杂度为n，最差情况下为n的平方，平均复杂度为n的平方
快速排序：不稳定，最好情况下为nlog(n)，最差情况下为n^{2}，平均复杂度为nlog(n)
归并排序：稳定，最好情况下为nlog(n)，最差情况下为nlog(n)，平均复杂度为nlog(n)
### 堆内存分配情况

### 一个英文文章，含有各种单词和标点符号，从中找出A-Z都出现过至少一次的最小子串，大小写不限

### 链表和数组分别适用于那些排序，为什么？
因为链表不支持随机访问，所以，最适合冒泡排序
数组支持随机访问，所以，一般的排序算法都支持
### 介绍一下数组，数组跟链表的区别，在数组和链表中查找一个特定值，数组和链表那个效率高？
数组和链表不多说，大家肯定都会
查找一个特定值时，想都不用想，肯定是数组效率高，因为数组可以随机访问
### 找数组中最大和最小元素，能否优化时间效率小于n？

### 求二叉树的最大距离，即相距最远的两个叶子节点，写代码

### 求单链表的中间节点，要求进行安全检查，直接运行的程序

### 两个栈实现一个队列，写代码

### 求二叉树的宽度，写代码

### 对十亿个屋无符号整数进行排序
首先，建立一个哈希表，然后统计每一个无符号整数出现的次数，然后扫描哈希表，一个整数出现几次，重复输出就可以啦

