### 排序有几种方式，分别介绍其实现原理？时间复杂度与空间复杂度？
具体答案看我的博客http://www.cnblogs.com/PIRATE-JFZHOU
### 平衡二叉树
平衡二叉树是这样一种二叉树，它的左右子树的深度相差不超过1,它的左右子树也符合上述的条件的二叉树
### STL中list和map对应的数据结构
STL中的list对应的是一个双向的链表，map的底层数据结构是红黑树
### 单向链表和双向链表的数据结构的实现
单向链表的实现
```
template<typename T>
struct list{
T val;
list * ptr;
}
```
双向链表的实现
```
template<typename T>
struct dou_list{
T val;
dou_list* pre;
dou_list* former;
}
```
### hashmap中value的底层存储结构
hashmap的底层存储结构都是红黑树
### 哈希的主要原理
哈希表是根据关键码值而直接进行访问的数据结构，也就是通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数
### 怎样判断一个链表有环
设置两个指针都指向头节点，然后两个指针同时出发，一个慢指针每次只走一步，快指针走两步，如果快指针为null，那么链表无环，如果在某一时刻，快指针等于慢指针，那么链表有环，程序如下：
```
bool judge(list* head){
	list* fast=head;
	list* slow=head;
	while(fast!=null){
        	list* lnode=fast;
        	if(lnode->next!=null){
                	lnode=lnode->next;
        	}
        	else
        	{
                	return false;
        	}
		slow=lnode;
		if(lnode->next!=null){
			lnode=lnode-next
		}
		else
		{
			return false;
		}
		fast=lnode;
		if(fast->val==slow->val){
			return true;
		}
	}
}
```
### 两个有序的单链表如何合并成一个有序的单链表
程序代码如下所示：
```
list * merge(list *list1,list* list2){
	if(list1==null){
		return list2;
	}
	if(list2==null){
		return list1;
	}
	list* lnode1=list1;
	list* lnode2=list2;
	list* res=null;
	list* nextlnode=res;
	while(lnode1!=null && lnode2!=null){
		list * lnode=new list;
		if(lnode1->val<lnode2->val){
			lnode->val=lnode1->val;
			lnode1=lnode1->next;
		}
		else{
			lnode->val=lnode2->val;
			lnode2=lnode2->next;
		}
		nextlnode->next=lnode;
		nextlnode=nextlnode->next;
	}
	while(lnode1!=null){
		list*lnode=new list;
		lnode->val=lnode1->val;
		nextlnode->next=lnode;
		nextlnode=nextlnode->next;
		lnode1=lnode1->next;
	}
	while(lnode2!=null){
		list*lnode=new list;
		lnode->val=lnode2->val;
		nextlnode->next=lnode;
		nextlnode=nextlnode->next;
		lnode2=lnode2->next;
	}
	return res;
}
```

