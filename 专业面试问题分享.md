### 排序有几种方式，分别介绍其实现原理？时间复杂度与空间复杂度？
```
具体答案看我的博客http://www.cnblogs.com/PIRATE-JFZHOU
```
### 平衡二叉树
```
平衡二叉树是这样一种二叉树，它的左右子树的深度相差不超过1,它的左右子树也符合上述的条件的二叉树
```
### STL中list和map对应的数据结构
```
STL中的list对应的是一个双向的链表，map的底层数据结构是红黑树
```
### 单向链表和双向链表的数据结构的实现
单向链表的实现
```
template<typename T>
struct list{
T val;
list * ptr;
}
```
双向链表的实现
```
template<typename T>
struct dou_list{
T val;
dou_list* pre;
dou_list* former;
}
```
### hashmap中value的底层存储结构
```
hashmap的底层存储结构都是红黑树
```
### 哈希的主要原理
```
哈希表是根据关键码值而直接进行访问的数据结构，也就是通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度
这个映射函数叫做散列函数
```
### 怎样判断一个链表有环
设置两个指针都指向头节点，然后两个指针同时出发，一个慢指针每次只走一步，快指针走两步，如果快指针为null，那么链表无环，如果在某一时刻，快指针等于慢指针，那么链表有环，程序如下：
```
bool judge(list* head){
	list* fast=head;
	list* slow=head;
	while(fast!=null){
        	list* lnode=fast;
        	if(lnode->next!=null){
                	lnode=lnode->next;
        	}
        	else
        	{
                	return false;
        	}
		slow=lnode;
		if(lnode->next!=null){
			lnode=lnode-next
		}
		else
		{
			return false;
		}
		fast=lnode;
		if(fast->val==slow->val){
			return true;
		}
	}
}
```
### 两个有序的单链表如何合并成一个有序的单链表
程序代码如下所示：
```
list * merge(list *list1,list* list2){
	if(list1==null){
		return list2;
	}
	if(list2==null){
		return list1;
	}
	list* lnode1=list1;
	list* lnode2=list2;
	list* res=null;
	list* nextlnode=res;
	while(lnode1!=null && lnode2!=null){
		list * lnode=new list;
		if(lnode1->val<lnode2->val){
			lnode->val=lnode1->val;
			lnode1=lnode1->next;
		}
		else{
			lnode->val=lnode2->val;
			lnode2=lnode2->next;
		}
		nextlnode->next=lnode;
		nextlnode=nextlnode->next;
	}
	while(lnode1!=null){
		list*lnode=new list;
		lnode->val=lnode1->val;
		nextlnode->next=lnode;
		nextlnode=nextlnode->next;
		lnode1=lnode1->next;
	}
	while(lnode2!=null){
		list*lnode=new list;
		lnode->val=lnode2->val;
		nextlnode->next=lnode;
		nextlnode=nextlnode->next;
		lnode2=lnode2->next;
	}
	return res;
}
```
### 一个特别大的数据，怎么计算给定范围的数组之和

### 五子棋怎么判赢
```
检查当前落子的一行，左上右下和左下右上斜线是否有5个同样颜色的棋子
```
### 布龙过滤器，主要还是检查一个数据是否在海量数据中的方法
```
哈希
```
### 俄罗斯方块游戏数据结构怎么设计？怎么表示形状？怎么表示消除？
```
一个二维数组，0和1,0表示有方块，1表示无方块
```
### 搜索的时候输入一个字开始提示怎么实现的

### 在使用淘点点的时候，怎么查找最近100家商店，数据量大，说出算法思想，要求效率高？

### 100个数怎么选出三个最大的数
```
我的想法是用冒泡排序就可以，循环三次，或者用直接选择排序也可以，时间复杂度为n,空间复杂度为1
```
### 找出一个字符串中第一个出现的次数为1的字符的下标
```
建立一个大小为256的字符数组，第一遍遍历数组，统计每个字符在字符串中出现的次数，并且存储在哈希表中，第二遍遍历时，
检查哈希表的值是否为1即可
```
### 双向链表排序用什么算法比较好？
```
因为双向链表不能随机访问，所以那些要求随机访问的都不理想，用冒泡可能好一些
```
### 红黑树，平衡二叉树和B树的区别
```
首先，红黑树和平衡二叉树都是二叉树，区别在于平衡二叉树保持着绝对的平衡，要使一棵树恢复到平衡二叉树可能需要很多步骤，
相比来说，红黑树是一种比较弱的平衡，也就是平衡条件不是非常苛刻，相比带来的好处是最多可以通过三次旋转变换使得一个二叉
树恢复平衡
其次，B树不是二叉树，它通常用在磁盘存储文件中
```
### 栈用数组怎么实现
```
这个题目剑指offer上有
```
### map的实现原理
```
map的底层数据结构是红黑树，红黑树从本质上讲是一种二叉搜索树，平均查找时间为log2(n)
```
### STL的容器有那些？分别介绍其实现原理
```
容器分为两种：
1、序列式容器，包括vector、list、deque、stack、queue、head、priority_queue、slist  
2、关联式容器，包括set、map、multiset、multimap、hashtable  
vector实质上是一种动态数组  
list是环形双向链表  
deque相比vector的单向增长，deque可以在前端插入数据，而且没有所谓的容量的概念  
stack是栈，底层实现只是将deque单端闭口而已  
queue是队列，有两种实现方式，一种是以list实现，一种是以deque实现  
priority_queue是以heap也就是堆的实现方式  
slist是单向链表  
关联式容器都是以红黑树为底层实现  
```
### 1,2,3,4,5,7,6这个序列的如果排序你会怎么做，为什么？如果完全无序会怎么做？
```
数组基本有序，所以用冒泡、插入实际上都可以，完全无序的话，归并排序
```
### 两个数进行交换，不额外使用变量，怎么做
```
x=x+y  
y=x-y  
x=x-y
```  
### 说出自己熟悉的排序算法以及每种算法的优缺点
```
插入排序：插入排序是稳定的排序，在最好情况下时间复杂度为n，最差情况下为n的平方，平均复杂度为n的平方  
shell排序：不稳定，最好情况下时间复杂度为n，最差为n的平方，平均复杂度为n的1.3次方  
选择排序：不稳定，最好情况下时间复杂度为n的平方，最差为n的平方，平均复杂度为n的平方  
堆排序：不稳定，最好情况下时间复杂度为nlog(n)，最差为nlog(n)，平均复杂度为nlog(n)  
冒泡排序：稳定，最好情况下时间复杂度为n，最差情况下为n的平方，平均复杂度为n的平方  
快速排序：不稳定，最好情况下为nlog(n)，最差情况下为n^{2}，平均复杂度为nlog(n)  
归并排序：稳定，最好情况下为nlog(n)，最差情况下为nlog(n)，平均复杂度为nlog(n)  
```
### 堆内存分配情况

### 一个英文文章，含有各种单词和标点符号，从中找出A-Z都出现过至少一次的最小子串，大小写不限

### 链表和数组分别适用于那些排序，为什么？
```
因为链表不支持随机访问，所以，最适合冒泡排序  
数组支持随机访问，所以，一般的排序算法都支持  
```
### 介绍一下数组，数组跟链表的区别，在数组和链表中查找一个特定值，数组和链表那个效率高？
```
数组和链表不多说，大家肯定都会  
查找一个特定值时，想都不用想，肯定是数组效率高，因为数组可以随机访问  
```
### 找数组中最大和最小元素，能否优化时间效率小于n？

### 求二叉树的最大距离，即相距最远的两个叶子节点，写代码

### 求单链表的中间节点，要求进行安全检查，直接运行的程序

### 两个栈实现一个队列，写代码

### 求二叉树的宽度，写代码

### 对十亿个屋无符号整数进行排序
```
建立一个哈希表，然后统计每一个无符号整数出现的次数，然后扫描哈希表，一个整数出现几次，重复输出就可以啦
```
### 关键字valatile的作用
```
代码优化，用volatile修饰的变量，访问时直接访问内存，而其他变量存在代码优化时，会访问最近访问的内存
```
### 用C实现面向对象（例如多态）

### C++虚函数、重载、多态是什么？虚函数实现原理？
```
重载是指在同一作用域中允许有多个同名函数，而这些函数的参数列表不同，包括参数个数、参数类型，参数次序不同，
不能以返回值为区分  
多态字面意思就是多种形态，具体到C++，就是一种接口，多种实现  
多态有很多实现方式，一种是通过重载和范型编程，重载和范型编程是在编译阶段就确定的;  
虚函数就是以virtual关键字声明的基类函数，如果在基类中将某个函数指定为virtual，并且派生类中另外有一个该函数的定义，
则编译器知道我们不想静态链接这个函数,虚函数的实现主要依赖与虚函数指针，在实际执行的时候，通过虚函数指针去确定具体调用那个函数
```
### vector的底层是怎样的？
```
vector底层数据结构就是一整块连续的内存，类似于动态数组
```
### C++三大特性（继承、多态、封装）

### new和malloc都能创建新的对象，区别在哪？那个效率高？

| 特征 | new/delete | malloc/free |
| ------------------------- |:----------------------------------:|:--------------------------------:|
| 分配内存的位置 | 自由存储区 | 堆 |
| 内存分配成功返回值 | 完整的类型指针 | void\*(空类型指针，需要时强制转换) |
| 内存分配直白后的返回值 | 默认抛出异常 | 返回null |
| 分配内存的大小 | 由编译器根据类型计算得出 | 必须显式的指出内存大小 |
| 处理数组 | 有处理数组的版本new[] | 必须用户计算数组的大小后进行内存分配 |
| 已分配内存的扩充 | 无法直观进行处理 | 使用realloc简单完成 |
| 是否相互调用 | 可以，具体看operator new/delete的实现 | 不可以调用new |
| 分配内存时内存不足 | 用户能够指定处理函数重新分配成分配器 | 无法通过用户代码进行处理 |
| 构造函数与析构函数 | 调用 | 不掉用 |
| 函数重载 | 允许 | 不允许 |

### 文件存储，文件删除，内存里面海有没有，能不能找回来？

### 函数变量存储在堆中还是栈中，什么时候分配什么时候回来？
```
函数变量存储在栈中，进入函数的时候分配内存存储，退出函数释放
```
### 构造函数和析构函数是否可以定义成虚函数？
```
构造函数不能，因为在定义变量的时候，每次都会调用构造函数实例化，如果构造函数是虚函数，那就不能实例化，
也就无法初始化虚函数指针列表
```
### 内部类的作用
```
内部类的作用就是不让外部访问，同时在本类内部又能提供较好的职能分解
```
### 索引的作用和实现？

### ==和equals区别
```
==主要用来比较整数  
equals主要用来比较浮点数
```
### 右值引用的作用

### auto关键字

### C++的lambda函数的实现原理，C++函数的对象是如何实现的

### C++11的几个智能指针再那么用

### vector实现高校内存管理的原理

### 头文件include ""和<>的区别
```
include""表示编译链接时优先搜索本地目录  
include<>表示编译时搜索系统目录
```
### 如果你定义一个string类，里面会有那些函数
```

```
### 指针引用的区别
```
第一，指针指是一个变量，这个变量存储的是一个地址，指向内存的一个存储单元，引用只是原来变量的一个别名，跟变量的实质时一样的
第二，引用不可以为空，当被创建的时候，必须初始化，指针可以时空值，可以在任何时候初始化
第三，可以有const指针，但是没有const引用
第四，指针可以有多级，但是引用智能呢个有一级
第五，指针的值初始化后可以改变，但是引用不可以
```

